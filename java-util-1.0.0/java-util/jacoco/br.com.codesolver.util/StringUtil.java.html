<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java-util</a> &gt; <a href="index.source.html" class="el_package">br.com.codesolver.util</a> &gt; <span class="el_source">StringUtil.java</span></div><h1>StringUtil.java</h1><pre class="source lang-java linenums">package br.com.codesolver.util;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.Collection;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Manipulação de texto.
 *
 * @author &lt;a href=&quot;mailto:luciano@codesolver.com.br&quot;&gt;Luciano Vieira Rodrigues&lt;/a&gt;
 * @since 2025-08-26
 */
public final class StringUtil {

    /** Log da classe. */
<span class="fc" id="L19">    private static final Logger LOGGER = Logger.getLogger(StringUtil.class.getName());</span>

    /** Máscara para decomposição dos octetos de endereço IP. */
    private static final int BYTE_MASK = 0xFF;

    /** Máscara para identificar um espaço em um texto.. */
    private static final String TEXT_SPACE = &quot; &quot;;

    /** Zero em modo texto. */
    private static final String TEXT_ZERO = &quot;0&quot;;

    /** Tamanho de uma estrutura de dados para IP em Bytes. */
    private static final int IP_LENGTH = 4;

    /** Ponto para separação de informações em textos (IP, por exemplo). */
    private static final String TEXT_PERIOD = &quot;.&quot;;

    /**
     * Expressão regular para identificar nomes de constantes.
     */
<span class="fc" id="L39">    private static final Pattern CONSTANT_NAME_EXPRESSION = Pattern.compile(&quot;^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$&quot;); </span>

    /** Lista de caracteres acentuados que devem ser substituidos. */
<span class="fc" id="L42">    private static final char[] INVALID_CHARS = {</span>
        'á', 'é', 'í', 'ó', 'ú',
        'à', 'è', 'ì', 'ò', 'ù',
        'â', 'ê', 'î', 'ô', 'û',
        'ä', 'ë', 'ï', 'ö', 'ü',
        'ã', 'ẽ', 'ĩ', 'õ', 'ũ',
        'ç',
        'Á', 'É', 'Í', 'Ó', 'Ú',
        'À', 'È', 'Ì', 'Ò', 'Ù',
        'Â', 'Ê', 'Î', 'Ô', 'Û',
        'Ä', 'Ë', 'Ï', 'Ö', 'Ü',
        'Ã', 'Ẽ', 'Ĩ', 'Õ', 'Ũ',
        'Ç' };

    /** Lista de caracteres para substituir a lista de caracteres acentuados. */
<span class="fc" id="L57">    private static final char[] REPLACE_CHARS = {</span>
        'a', 'e', 'i', 'o', 'u',
        'a', 'e', 'i', 'o', 'u',
        'a', 'e', 'i', 'o', 'u',
        'a', 'e', 'i', 'o', 'u',
        'a', 'e', 'i', 'o', 'u',
        'c',
        'A', 'E', 'I', 'O', 'U',
        'A', 'E', 'I', 'O', 'U',
        'A', 'E', 'I', 'O', 'U',
        'A', 'E', 'I', 'O', 'U',
        'A', 'E', 'I', 'O', 'U',
        'C' };

    /**
     * Expressão regular para ignorar os caracteres normais (a..z, A..Z, 0..9)
     * e remover os demais caracteres.
     */
    private static final String INVALID_EXPRESSION = &quot;[^a-zA-Z0-9 \\-\\_\\.\\,\\/]&quot;; 

    /**
     * Construtor oculto.
     */
    private StringUtil() {
    }

    /**
     * Remove os caracteres especiais de um texto.
     *
     * @param text Texto que deverá ser normalizado sem acentos.
     * @return Texto sem acentos ou caracteres especiais.
     */
    public static String clean(String text) {
<span class="fc" id="L90">        String aux = text;</span>
        // Removendo os acentos:
<span class="fc bfc" id="L92" title="All 2 branches covered.">        for (int i = 0; i &lt; INVALID_CHARS.length; i++) {</span>
<span class="fc" id="L93">            aux = aux.replace(INVALID_CHARS[i], REPLACE_CHARS[i]);</span>
        }
        // Removendo os demais caracteres especiais:
<span class="fc" id="L96">        Pattern pattern = Pattern.compile(INVALID_EXPRESSION);</span>
<span class="fc" id="L97">        Matcher matcher = pattern.matcher(aux);</span>
<span class="fc" id="L98">        return matcher.replaceAll(&quot;&quot;); </span>
    }

    /**
     * Adiciona espaços em branco a direita do texto.
     *
     * @param text   Texto original.
     * @param length Tamanho final do texto.
     * @return Texto com espaços em branco a direita.
     */
    public static String padRight(String text, int length) {
<span class="fc" id="L109">        return padRight(text, TEXT_SPACE, length); </span>
    }

    /**
     * Adiciona um texto a direita do texto original, até o tamanho informado.
     *
     * @param text   Texto original.
     * @param stuff  Texto para adicionar.
     * @param length Tamanho final do texto.
     * @return {@link String}
     */
    public static String padRight(String text, String stuff, int length) {
<span class="fc" id="L121">        StringBuilder aux = new StringBuilder();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (length &lt; text.length()) {</span>
<span class="fc" id="L123">            aux.append(text.substring(0, length));</span>
        } else {
<span class="fc" id="L125">            aux.append(text);</span>
            int difference;
<span class="fc bfc" id="L127" title="All 2 branches covered.">            while ((difference = length - aux.length()) &gt; 0) {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">                if (stuff.length() &gt; difference) {</span>
<span class="fc" id="L129">                    aux.append(stuff.substring(0, difference));</span>
                } else {
<span class="fc" id="L131">                    aux.append(stuff);</span>
                }
            }
        }
<span class="fc" id="L135">        return aux.toString();</span>
    }

    /**
     * Adiciona espaços em branco a esquerda do texto.
     *
     * @param text   Texto original.
     * @param length Tamanho final do texto.
     * @return Texto com espacos em branco a direita.
     */
    public static String padLeft(String text, int length) {
<span class="fc" id="L146">        return padLeft(text, TEXT_SPACE, length); </span>
    }

    /**
     * Adiciona um texto a esquerda do texto original, ate o tamanho informado.
     *
     * &lt;p&gt;
     * Quando o tamanho do texto é maior que o tamanho final, será considerado
     * o final do texto como válido, já que o objetivo é adicionar textos à
     * esquerda.
     *
     * @param text   Texto original.
     * @param stuff  Texto para adicionar.
     * @param length Tamanho final do texto.
     * @return {@link String}
     */
    public static String padLeft(String text, String stuff, int length) {
<span class="fc" id="L163">        String aux = text;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (length &lt; aux.length()) {</span>
<span class="fc" id="L165">            aux = aux.substring(aux.length() - length);</span>
        } else {
            int difference;
<span class="fc bfc" id="L168" title="All 2 branches covered.">            while ((difference = length - aux.length()) &gt; 0) {</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">                if (stuff.length() &gt; difference) {</span>
<span class="fc" id="L170">                    aux = stuff.substring(difference - 1) + aux;</span>
                } else {
<span class="fc" id="L172">                    aux = stuff + aux;</span>
                }
            }
        }
<span class="fc" id="L176">        return aux;</span>
    }

    /**
     * Adiciona zeros a esquerda de um texto, até o tamanho informado.
     *
     * @param value  Valor unicial.
     * @param length Tamanho final do texto.
     * @return Texto informando um valor acrescido de zeros a esquerda.
     */
    public static String leftZero(int value, int length) {
<span class="fc" id="L187">        String result = String.valueOf(value);</span>
<span class="fc" id="L188">        result = padLeft(result, TEXT_ZERO, length); </span>
<span class="fc" id="L189">        return result;</span>
    }

    /**
     * Converte uma matriz de bytes em uma sequência de caracteres hexadecimais.
     *
     * @param value Matriz de bytes
     * @return HASH no formato hexadecimal.
     */
    public static String toHex(byte[] value) {
<span class="fc" id="L199">        StringBuilder builder = new StringBuilder();</span>
<span class="fc" id="L200">        boolean canDiscardZero = true;</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for (byte x : value) {</span>
<span class="fc bfc" id="L202" title="All 4 branches covered.">            if (x == 0 &amp;&amp; canDiscardZero) {</span>
<span class="fc" id="L203">                continue;</span>
            } else {
<span class="fc" id="L205">                canDiscardZero = false;</span>
            }
<span class="fc" id="L207">            String aux = Integer.toHexString(BYTE_MASK &amp; x);</span>
<span class="fc bfc" id="L208" title="All 4 branches covered.">            if (aux.length() == 1 &amp;&amp; !builder.isEmpty()) {</span>
<span class="fc" id="L209">                builder.append(TEXT_ZERO); </span>
            }
<span class="fc" id="L211">            builder.append(aux);</span>
        }
<span class="fc" id="L213">        return builder.toString();</span>
    }

    /**
     * Converte uma matriz de bytes em uma sequência de caracteres hexadecimais,
     * com tamanho máximo definido.
     *
     * @param value  Matriz de bytes
     * @param length Tamanho máximo da matriz.
     * @return HASH no formato hexadecimal.
     */
    public static String toHexSpaced(byte[] value, int length) {
<span class="fc" id="L225">        byte[] croped = Arrays.copyOf(value, length);</span>
<span class="fc" id="L226">        return toHexSpaced(croped);</span>
    }

    /**
     * Converte uma matriz de bytes em uma sequência de caracteres hexadecimais,
     * separados por espaços em branco.
     *
     * @param value Matriz de bytes
     * @return HASH no formato hexadecimal.
     */
    public static String toHexSpaced(byte[] value) {
<span class="fc" id="L237">        StringBuilder builder = new StringBuilder();</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (byte x : value) {</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">            if (builder.length() != 0) {</span>
<span class="fc" id="L240">                builder.append(TEXT_SPACE); </span>
            }
<span class="fc" id="L242">            String aux = Integer.toHexString(BYTE_MASK &amp; x);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            if (aux.length() == 1) {</span>
<span class="fc" id="L244">                builder.append(TEXT_ZERO); </span>
            }
<span class="fc" id="L246">            builder.append(aux);</span>
        }

<span class="fc" id="L249">        return builder.toString();</span>
    }

    /**
     * Converte uma expressão hexadecimal para uma matriz de bytes.
     *
     * @param hex HASH no formato hexadecimal.
     * @return byte[] Matriz de bytes extraída.
     */
    public static byte[] hexToBytes(String hex) {
        // Normalizando o tamanho do hash...
<span class="fc" id="L260">        String text = hex.replaceAll(TEXT_SPACE, &quot;&quot;);  </span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        if ((text.length() % 2) != 0) {</span>
<span class="fc" id="L262">            text = TEXT_ZERO + text; </span>
        }
<span class="fc" id="L264">        byte[] result = new byte[text.length() / 2];</span>
<span class="fc" id="L265">        char[] hash = text.toCharArray();</span>
<span class="fc bfc" id="L266" title="All 2 branches covered.">        for (int i = 0; i &lt; hash.length; i += 2) {</span>
<span class="fc" id="L267">            String aux = &quot;0x&quot; + hash[i] + hash[i + 1]; </span>
<span class="fc" id="L268">            result[i / 2] = Integer.decode(aux).byteValue();</span>
        }

<span class="fc" id="L271">        return result;</span>
    }

    /**
     * Codifica uma string contendo um IPv4 para um array de bytes.
     *
     * @param ip IPv4 no formato 255.255.255.255.
     * @return byte[] array de bytes onde cada uma das quatro posições do array é um
     *         octeto do IP.
     * @throws IllegalArgumentException Não é um IP válido.
     */
    public static byte[] encodeIPv4(String ip) {
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (ip == null) {</span>
<span class="fc" id="L284">            throw new IllegalArgumentException(&quot;Parâmetro de entrada não deve ser nulo.&quot;); </span>
        }

<span class="fc" id="L287">        Pattern p = Pattern.compile(</span>
                &quot;\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b&quot;); 
<span class="fc" id="L289">        Matcher m = p.matcher(ip);</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">        if (!m.matches()) {</span>
<span class="fc" id="L291">            throw new IllegalArgumentException(&quot;Formato esperado 255.255.255.255&quot;); </span>
        }

<span class="fc" id="L294">        String[] text = ip.split(&quot;\\.&quot;); </span>
<span class="fc" id="L295">        byte[] octets = new byte[IP_LENGTH];</span>
<span class="fc" id="L296">        int index = 0;</span>
<span class="fc" id="L297">        octets[index]   = (byte) (Integer.parseInt(text[index]) &amp; BYTE_MASK);</span>
<span class="fc" id="L298">        octets[++index] = (byte) (Integer.parseInt(text[index]) &amp; BYTE_MASK);</span>
<span class="fc" id="L299">        octets[++index] = (byte) (Integer.parseInt(text[index]) &amp; BYTE_MASK);</span>
<span class="fc" id="L300">        octets[++index] = (byte) (Integer.parseInt(text[index]) &amp; BYTE_MASK);</span>
<span class="fc" id="L301">        return octets;</span>
    }

    /**
     * Formata um array de 4 bytes, para uma string no formato IPv4.
     *
     * @param ip array de 4 bytes correspondendo aos 4 octetos do IPv4.
     * @return string formatada no padrão 255.255.255.255.
     * @throws IllegalArgumentException Não foi fornecido um IP válido.
     */
    public static String decodeIPv4(byte[] ip) {
<span class="fc bfc" id="L312" title="All 4 branches covered.">        if (ip == null || ip.length &lt; IP_LENGTH) {</span>
<span class="fc" id="L313">            throw new IllegalArgumentException(&quot;Cada um dos quatro bytes deve corresponder a um octeto do IP.&quot;);</span>
        }

<span class="fc" id="L316">        int index = 0;</span>
<span class="fc" id="L317">        StringBuilder strFormatada = new StringBuilder();</span>
<span class="fc" id="L318">        strFormatada.append((short) (ip[index++] &amp; BYTE_MASK)).append(TEXT_PERIOD);</span>
<span class="fc" id="L319">        strFormatada.append((short) (ip[index++] &amp; BYTE_MASK)).append(TEXT_PERIOD);</span>
<span class="fc" id="L320">        strFormatada.append((short) (ip[index++] &amp; BYTE_MASK)).append(TEXT_PERIOD);</span>
<span class="fc" id="L321">        strFormatada.append((short) (ip[index++] &amp; BYTE_MASK));</span>

<span class="fc" id="L323">        return strFormatada.toString();</span>
    }

    /**
     * Lê as propriedades de um objeto e gera texto descrevendo-o com seus
     * valores. Pode ser utilizado para tratar os métodos toString de
     * objetos POJO.
     *
     * @param value Objeto para decodificar.
     * @return @{link String}.
     */
    public static String toString(Object value) {
<span class="fc" id="L335">        StringBuilder builder = new StringBuilder();</span>

<span class="fc" id="L337">        Class&lt;?&gt; clazz = value.getClass();</span>
<span class="fc" id="L338">        builder.append(clazz.getName());</span>
<span class="fc" id="L339">        builder.append(&quot;[&quot;); </span>

<span class="fc" id="L341">        boolean first = true;</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">        for (Field field : clazz.getDeclaredFields()) {</span>
            // Se for o campo de versão serial da classe.
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">            if (&quot;serialVersionUID&quot;.equals(field.getName())) { </span>
<span class="nc" id="L345">                continue;</span>
            }
            // Se for uma constante.
<span class="fc" id="L348">            Matcher matcher = CONSTANT_NAME_EXPRESSION.matcher(field.getName());</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">            if (matcher.matches()) {</span>
<span class="nc" id="L350">                continue;</span>
            }
            // Se não for o primeiro campo, adicionar uma vírgula.
<span class="fc bfc" id="L353" title="All 2 branches covered.">            if (!first) {</span>
<span class="fc" id="L354">                builder.append(&quot;,&quot;); </span>
            }
            try {
                // Tratando campos de coleções:
                try {
<span class="nc bnc" id="L359" title="All 2 branches missed.">                    if (field.getType().asSubclass(Collection.class) != null) {</span>
<span class="nc" id="L360">                        builder.append(field.getName()).append(&quot;=(&quot;).append(field.getType().getName()).append(&quot;)&quot;);  </span>
                    }
<span class="fc" id="L362">                } catch (ClassCastException e) {</span>
<span class="fc" id="L363">                    field.setAccessible(true);</span>
<span class="fc" id="L364">                    builder.append(field.getName()).append(&quot;=&quot;).append(field.get(value)); </span>
<span class="nc" id="L365">                }</span>
<span class="nc" id="L366">            } catch (IllegalArgumentException e) {</span>
<span class="nc" id="L367">                LOGGER.warning(e.getMessage());</span>
<span class="nc" id="L368">            } catch (IllegalAccessException e) {</span>
<span class="nc" id="L369">                LOGGER.warning(e.getMessage());</span>
<span class="pc" id="L370">            }</span>
<span class="fc" id="L371">            first = false;</span>
        }

<span class="fc" id="L374">        builder.append(&quot;]&quot;); </span>

<span class="fc" id="L376">        return builder.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>